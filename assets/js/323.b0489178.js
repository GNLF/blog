(window.webpackJsonp=window.webpackJsonp||[]).push([[323],{794:function(t,e,a){"use strict";a.r(e);var v=a(17),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"web开发架构变迁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web开发架构变迁"}},[t._v("#")]),t._v(" Web开发架构变迁")]),t._v(" "),a("h2",{attrs:{id:"前后端不分的时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前后端不分的时代"}},[t._v("#")]),t._v(" 前后端不分的时代")]),t._v(" "),a("p",[t._v("互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。可称之为 Web 1.0 时代，非常适合创业型小项目，经常 3-5 人搞定所有开发。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/vue/web1.0.jpg",alt:"img"}})]),t._v(" "),a("p",[t._v("这种模式的好处是：简单明快，本地开启一个 Tomcat 或 Apache 服务器环境就能开发，调试什么的都还好，只要业务不太复杂。 然而业务总会变复杂，业务的复杂会让 Service 越来越多，参与开发的人员也很可能从几个人快速扩张到几十人。代码可维护性也原来越差。")]),t._v(" "),a("h2",{attrs:{id:"后端mvc时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后端mvc时代"}},[t._v("#")]),t._v(" 后端MVC时代")]),t._v(" "),a("p",[t._v("为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，这是后端的 MVC 时代。 代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。例如在PHP中为了让 View 层更简单干脆，还可以选择 smarty 等模板，使得模板里写不了 php 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/vue/mvc.png",alt:"img"}})]),t._v(" "),a("p",[t._v("那时的前端工程师，实际上只是负责写模板。后端代码读取模板，替换变量，渲染出页面。")]),t._v(" "),a("h2",{attrs:{id:"ajax的spa时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax的spa时代"}},[t._v("#")]),t._v(" Ajax的SPA时代")]),t._v(" "),a("blockquote",[a("p",[t._v("今天，需要在单个页面之间切换的 Web 应用模式似乎过时了...")])]),t._v(" "),a("p",[t._v("历史滚滚往前，2004 年 Gmail 像风一样来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/vue/web2.0.jpg",alt:"img"}})]),t._v(" "),a("p",[t._v("这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/img/vue/spa.png",alt:"img"}})]),t._v(" "),a("p",[t._v("对于 SPA 应用有几个很重要的挑战：")]),t._v(" "),a("h3",{attrs:{id:"前后端接口的约定。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前后端接口的约定。"}},[t._v("#")]),t._v(" 前后端接口的约定。")]),t._v(" "),a("p",[t._v("如果后端的接口一塌糊涂，业务模型不够稳定，那么前端开发会很痛苦。在项目中不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。")]),t._v(" "),a("h3",{attrs:{id:"前端开发的复杂度控制。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端开发的复杂度控制。"}},[t._v("#")]),t._v(" 前端开发的复杂度控制。")]),t._v(" "),a("p",[t._v("SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。")]),t._v(" "),a("h2",{attrs:{id:"前端为主的mv-时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端为主的mv-时代"}},[t._v("#")]),t._v(" 前端为主的MV*时代")]),t._v(" "),a("p",[t._v("为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 view、controller、model。 好处很明显：")]),t._v(" "),a("p",[t._v("前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。")]),t._v(" "),a("p",[t._v("前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。")]),t._v(" "),a("p",[t._v("部署相对独立，产品体验可以快速改进。")]),t._v(" "),a("h2",{attrs:{id:"前端组件化时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端组件化时代"}},[t._v("#")]),t._v(" 前端组件化时代")]),t._v(" "),a("blockquote",[a("p",[t._v("2013年，Facebook宣布推出React，引入了基于组件的架构。不久之后，大多数其他框架，如Vue、Angular，都选择组件化。")])]),t._v(" "),a("p",[t._v("差不多在2015年左右，我们的思维方式有个大跳变——从熟悉的 MVC 模式转组件化开发模式。")]),t._v(" "),a("p",[t._v("组件化，给前端开发带来了极大的效率提升，是近几年以来web开发发展的趋势，各种组件化的用户界面库，框架也层出不穷，如，React，Vue，angular等，这些框架关于组件化都有各自的实现，推崇理念，与编程规范，各大框架的支持者之间的争论也是向来不断，而若想在不同框架间切换，成本还是挺高的，因为毕竟谁都希望自己能占主流，占据绝对优势地位，就像当前IE与网景浏览器之争，延续到现在，各类浏览器标准兼容差异万千，近年来w3c不断在为web标准规范做努力，Web Components就是推出的关于组件化的一个标准，希望它能将组件化更好的带进web开发，同时尽量保证标准规范，开发者可以更好的关注于开发，而不是框架选择与争论之上。")]),t._v(" "),a("h3",{attrs:{id:"web-components"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-components"}},[t._v("#")]),t._v(" Web Components")]),t._v(" "),a("p",[t._v("Web Components它由四项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。 Web Components它本身不是一个规范，他是由W3C提出的另外4个规范的合集。这四个规范是：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("技术")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Custom elements（自定义元素）")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("Shadow DOM（影子DOM）")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("HTML templates（HTML模板）")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("<template>")]),t._v(" 和 "),a("code",[t._v("<slot>")]),t._v(" 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("HTML Imports（HTML导入）")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。")])])])]),t._v(" "),a("p",[t._v("总体来说，Web component他是w3c标准，基本会是组件技术的最终方向，但是需要大量的时间来让来让浏览器支持("),a("a",{attrs:{href:"https://caniuse.com/#search=web%20component",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击查看兼容情况"),a("OutboundLink")],1),t._v(")。")])])}),[],!1,null,null,null);e.default=r.exports}}]);