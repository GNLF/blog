(window.webpackJsonp=window.webpackJsonp||[]).push([[267],{659:function(e,s,a){"use strict";a.r(s);var t=a(17),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue原理-深入响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue原理-深入响应式原理"}},[e._v("#")]),e._v(" vue原理-深入响应式原理")]),e._v(" "),a("p",[e._v("现在是时候深入底层原理了！Vue 最显著的特性之一，就是侵入性不是很强的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。在本节中，我们将开始深入挖掘 Vue 响应式系统的底层细节。")]),e._v(" "),a("h2",{attrs:{id:"如何追踪变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何追踪变化"}},[e._v("#")]),e._v(" 如何追踪变化")]),e._v(" "),a("p",[e._v("把一个普通 Javascript 对象传给 Vue 实例的 "),a("code",[e._v("data")]),e._v(" 选项，Vue 将遍历此对象所有的属性，并使用 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer"}},[e._v("Object.defineProperty"),a("OutboundLink")],1),e._v(" 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。")]),e._v(" "),a("p",[e._v("getter/setter 对于用户来说是不可见的，但是在内部，通过它们可以让 Vue 在访问属性时进行依赖追踪，以及修改属性时进行变更通知。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式并不同，所以你可能需要安装 "),a("a",{attrs:{href:"https://github.com/vuejs/vue-devtools",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-devtools"),a("OutboundLink")],1),e._v(" 来获取更加友好的检查接口。")]),e._v(" "),a("p",[e._v("每个组件实例都有相应的 "),a("strong",[e._v("watcher")]),e._v(" 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 "),a("code",[e._v("setter")]),e._v(" 被调用时，会通知 "),a("code",[e._v("watcher")]),e._v(" 重新计算，从而致使它关联的组件得以更新。")]),e._v(" "),a("p",[a("img",{attrs:{src:"amWiki/images/data.png",alt:"Reactivity Cycle"}})]),e._v(" "),a("h2",{attrs:{id:"变化检测问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变化检测问题"}},[e._v("#")]),e._v(" 变化检测问题")]),e._v(" "),a("p",[e._v("受现代 Javascript 的限制（以及废弃 "),a("code",[e._v("Object.observe")]),e._v("），Vue "),a("strong",[e._v("无法检测到对象属性的添加或删除")]),e._v("。由于 Vue 会在初始化实例时对属性执行 "),a("code",[e._v("getter/setter")]),e._v(" 转化过程，所以属性必须在 "),a("code",[e._v("data")]),e._v(" 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var vm = new Vue({\n  data: {\n    a: 1\n  }\n})\n// `vm.a` 是响应式的\n\nvm.b = 2\n// `vm.b` 不是响应式的\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 "),a("code",[e._v("Vue.set(object, key, value)")]),e._v(" 方法将响应属性添加到嵌套的对象上：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Vue.set(vm.someObject, 'b', 2)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("你还可以使用 "),a("code",[e._v("vm.$set")]),e._v(" 实例方法，这也是全局 "),a("code",[e._v("Vue.set")]),e._v(" 方法的别名：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("this.$set(this.someObject,'b',2)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("有时你想向已有对象上添加一些属性，例如使用 "),a("code",[e._v("Object.assign()")]),e._v(" 或 "),a("code",[e._v("_.extend()")]),e._v(" 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("也有一些数组相关的问题，之前已经在"),a("a",{attrs:{href:"https://vue.docschina.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9",target:"_blank",rel:"noopener noreferrer"}},[e._v("列表渲染"),a("OutboundLink")],1),e._v("中讲过。")]),e._v(" "),a("h2",{attrs:{id:"声明响应式属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明响应式属性"}},[e._v("#")]),e._v(" 声明响应式属性")]),e._v(" "),a("p",[e._v("由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕是一个空值：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var vm = new Vue({\n  data: {\n    // 声明 message 为一个空值字符串\n    message: ''\n  },\n  template: '<div>{{ message }}</div>'\n})\n// 之后设置 `message`\nvm.message = 'Hello!'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("如果你未在 data 选项中声明 "),a("code",[e._v("message")]),e._v("，Vue 会警告你 render 函数正在试图访问的一个属性，在实例中并不存在。")]),e._v(" "),a("p",[e._v("这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑："),a("code",[e._v("data")]),e._v(" 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。")]),e._v(" "),a("h2",{attrs:{id:"异步更新队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[e._v("#")]),e._v(" 异步更新队列")]),e._v(" "),a("p",[e._v("可能你还没有注意到，Vue "),a("strong",[e._v("异步")]),e._v("执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 "),a("code",[e._v("Promise.then")]),e._v(" 和 "),a("code",[e._v("MessageChannel")]),e._v("，如果执行环境不支持，会采用 "),a("code",[e._v("setTimeout(fn, 0)")]),e._v(" 代替。")]),e._v(" "),a("p",[e._v("例如，当你设置 "),a("code",[e._v("vm.someData = 'new value'")]),e._v(" ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 "),a("code",[e._v("Vue.nextTick(callback)")]),e._v(" 。这样回调函数在 DOM 更新完成后就会调用。例如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<div id=\"example\">{{ message }}</div>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // 更改数据\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("在组件内使用 "),a("code",[e._v("vm.$nextTick()")]),e._v(" 实例方法特别方便，因为它不需要全局 "),a("code",[e._v("Vue")]),e._v(" ，并且回调函数中的 "),a("code",[e._v("this")]),e._v(" 将自动绑定到当前的 Vue 实例上：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Vue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: 'not updated'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => 'not updated'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => 'updated'\n      })\n    }\n  }\n})\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);