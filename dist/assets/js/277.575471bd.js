(window.webpackJsonp=window.webpackJsonp||[]).push([[277],{629:function(s,a,n){"use strict";n.r(a);var e=n(17),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"组件知识点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件知识点"}},[s._v("#")]),s._v(" 组件知识点")]),s._v(" "),n("h3",{attrs:{id:"命名方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#命名方案"}},[s._v("#")]),s._v(" 命名方案")]),s._v(" "),n("p",[s._v("可以通过两种可选方式，定义组件名称：")]),s._v(" "),n("h4",{attrs:{id:"串联式命名-kebab-case"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#串联式命名-kebab-case"}},[s._v("#")]),s._v(" 串联式命名(kebab-case)")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('my-component-name', { /* ... */ })\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("使用串联式命名(kebab-case)定义一个组件，在引用其自定义元素时，你必须也使用串联式命名(kebab-case)，例如 "),n("code",[s._v("<my-component-name>")]),s._v("。")]),s._v(" "),n("h4",{attrs:{id:"pascal-式命名-pascalcase"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pascal-式命名-pascalcase"}},[s._v("#")]),s._v(" Pascal 式命名(PascalCase)")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('MyComponentName', { /* ... */ })\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("使用 Pascal 式命名(PascalCase)定义一个组件，在引用其自定义元素时，两种方式都可以使用。也就是说 "),n("code",[s._v("<my-component-name>")]),s._v(" 和 "),n("code",[s._v("<MyComponentName>")]),s._v(" 都是可以接受的。然而要注意，直接在 DOM 中（即，非字符串模板）引用自定义元素，串联式命名(kebab-case)是唯一有效的命名方式。")]),s._v(" "),n("h2",{attrs:{id:"全局注册方式-global-registration"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局注册方式-global-registration"}},[s._v("#")]),s._v(" 全局注册方式(global registration)")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('my-component-name', {\n  // ... options ...\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("可以在之后（通过 "),n("code",[s._v("new Vue")]),s._v("）创建的 Vue 根实例的模板中引用。例如：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('component-a', { /* ... */ })\nVue.component('component-b', { /* ... */ })\nVue.component('component-c', { /* ... */ })\n\nnew Vue({ el: '#app' })\n<div id=\"app\">\n  <component-a></component-a>\n  <component-b></component-b>\n  <component-c></component-c>\n</div>\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("这甚至可以应用于所有子组件，这意味着，这三个组件还可以在每个其他组件_内部_使用。")]),s._v(" "),n("h2",{attrs:{id:"局部注册方式-local-registration"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#局部注册方式-local-registration"}},[s._v("#")]),s._v(" 局部注册方式(local registration)")]),s._v(" "),n("p",[s._v("全局注册方式并不是很合适。例如，如果你使用一个类似 webpack 的模块构建系统，全局注册所有组件，意味着就算你不引用某个组件，它仍然会打包到最终的构建 bundle 中。这会增加 JavaScript 的体积，让用户下载多余的代码。")]),s._v(" "),n("p",[s._v("在下面这些示例中，可以将你的组件定义为纯 JavaScript 对象：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var ComponentA = { /* ... */ }\nvar ComponentB = { /* ... */ }\nvar ComponentC = { /* ... */ }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("然后，在 "),n("code",[s._v("components")]),s._v(" 选项中，定义你需要用到的组件：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("new Vue({\n  el: '#app'\n  components: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n  }\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("对于 "),n("code",[s._v("components")]),s._v(" 对象的每个属性，对象的 key 是自定义元素的名称，而 value 包含着组件的选项对象。")]),s._v(" "),n("p",[s._v("注意，"),n("strong",[s._v("局部注册的组件在子组件中无法访问")]),s._v("。例如，如果你想要 在 "),n("code",[s._v("ComponentB")]),s._v(" 中访问 "),n("code",[s._v("ComponentA")]),s._v("，你必须使用：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var ComponentA = { /* ... */ }\n\nvar ComponentB = {\n  components: {\n    'component-a': ComponentA\n  },\n  // ...\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("或者，如果使用 ES2015 模块（例如，通过 Babel 和 webpack 进行转译），则看起来可能类似这样：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("import ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  // ...\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("注意，在 ES2015+ 中，在一个对象放置类似 "),n("code",[s._v("ComponentA")]),s._v(" 这样的变量名称，其实是 "),n("code",[s._v("ComponentA: ComponentA")]),s._v(" 的简写形式，也就是说，变量的名称：")]),s._v(" "),n("ul",[n("li",[s._v("既是在模板中引用的自定义元素的名称")]),s._v(" "),n("li",[s._v("而且，也是包含组件选项对象的变量的引用名")])]),s._v(" "),n("h2",{attrs:{id:"prop-命名方案（驼峰式和串联式）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prop-命名方案（驼峰式和串联式）"}},[s._v("#")]),s._v(" prop 命名方案（驼峰式和串联式）")]),s._v(" "),n("p",[s._v("HTML 属性名称对大小写不敏感，因此浏览器会将所有大写字符解释为小写字符。也就是说。当你在你 DOM 模板中书写 prop 时，你应当将驼峰式(camelCase)转写为等价的（连字符分割的）串联式(kebab-case)：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('blog-post', {\n  // 在 JavaScript 中使用驼峰式(camelCase)\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n\x3c!-- 在 HTML 中使用串联式(kebab-case) --\x3e\n<blog-post post-title=\"hello!\"></blog-post>\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("再次申明，如果是在使用字符串模板的场景，则没有这些限制。")]),s._v(" "),n("h2",{attrs:{id:"prop-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prop-类型"}},[s._v("#")]),s._v(" prop 类型")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("props: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("h2",{attrs:{id:"单向数据流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流"}},[s._v("#")]),s._v(" 单向数据流")]),s._v(" "),n("p",[s._v("所有 props 都在子组件和父组件之间形成一个"),n("strong",[s._v("单向往下流动的数据绑定")]),s._v("：当父组件中的属性更新时，数据就会向下流动到子组件，但是反过来，子组件属性更新时，父组件并不会感知到子组件的数据变化。这种机制可以防止子组件意外地修改了父组件的状态，造成应用程序的数据流动变得难于理解。")]),s._v(" "),n("p",[s._v("此外，每次父组件更新时，子组件中所有的 props 都会更新为最新值。也就是说，你"),n("strong",[s._v("不应该")]),s._v("试图在子组件内部修改 prop。如果你这么做，Vue 就会在控制台给出警告。")]),s._v(" "),n("p",[s._v("诱使我们修改 prop 的原因，通常有两种：")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("**prop 用于传递初始值(initial value)；之后子组件需要将 prop 转为一个局部数据属性。**在这种情况中，最好定义一个局部的 data 属性，然后将 prop 的值，作为局部属性初始值。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("props: ['initialCounter'],\ndata: function () {\n  return {\n    counter: this.initialCounter\n  }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("**prop 用于传递一个需要转换的未加工值(raw value)。**在这种情况中，最好预先定义一个 computed 属性，然后在其函数内部引用 prop 的值：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("props: ['size'],\ncomputed: {\n  normalizedSize: function () {\n    return this.size.trim().toLowerCase()\n  }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])])]),s._v(" "),n("p",[s._v("注意，JavaScript 中的对象和数组都是通过引用(reference)传递的，因此，如果 prop 是一个数组或对象，则在子组件内部改变对象或数组本身，"),n("strong",[s._v("仍然会")]),s._v("影响到父组件状态。")]),s._v(" "),n("h2",{attrs:{id:"prop-验证"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prop-验证"}},[s._v("#")]),s._v(" prop 验证")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('my-component', {\n  props: {\n    // 基本类型(base type)的检查（`null` 表示接受所有类型）\n    propA: Number,\n    // 多种可能的类型\n    propB: [String, Number],\n    // 必须传递，且 String 类型\n    propC: {\n      type: String,\n      required: true\n    },\n    // Number 类型，有一个默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // Object 类型，有一个默认值\n    propE: {\n      type: Object,\n      // Object/Array 类型，\n      // 默认必须返回一个工厂函数\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 值必须是这些字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br")])]),n("h3",{attrs:{id:"类型检查"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型检查"}},[s._v("#")]),s._v(" 类型检查")]),s._v(" "),n("p",[n("code",[s._v("type")]),s._v(" 可以是以下原生构造函数之一：")]),s._v(" "),n("ul",[n("li",[s._v("String")]),s._v(" "),n("li",[s._v("Number")]),s._v(" "),n("li",[s._v("Boolean")]),s._v(" "),n("li",[s._v("Array")]),s._v(" "),n("li",[s._v("Object")]),s._v(" "),n("li",[s._v("Date")]),s._v(" "),n("li",[s._v("Function")]),s._v(" "),n("li",[s._v("Symbol")])]),s._v(" "),n("h2",{attrs:{id:"非-prop-特性-non-prop-attributes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#非-prop-特性-non-prop-attributes"}},[s._v("#")]),s._v(" 非 prop 特性(non-prop attributes)")]),s._v(" "),n("p",[s._v("非 prop 特性，就是指无须遵循 prop 定义规则，而是可以直接传入到组件的 HTML 属性(attribute)。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('<bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("然后，"),n("code",[s._v('data-date-picker="activated"')]),s._v(" 特性就会被自动添加到 "),n("code",[s._v("bootstrap-date-input")]),s._v(" 组件的根元素上。")])])}),[],!1,null,null,null);a.default=t.exports}}]);