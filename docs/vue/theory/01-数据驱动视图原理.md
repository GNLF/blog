# Vue数据驱动视图原理

### Object.defineProperty()

Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

#### 参数

| 参数       | 描述                           |
| :--------- | :----------------------------- |
| obj        | 要在其上定义属性的对象。       |
| prop       | 要定义或修改的属性的名称。     |
| descriptor | 将被定义或修改的属性的描述符。 |

#### 返回值

被传递给函数的对象。

## 什么是数据驱动

数据驱动是vuejs最大的特点。在vuejs中，所谓的数据驱动就是**当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom**。

比如说我们点击一个button，需要元素的文本进行是和否的切换。在jquery刀耕火种的年代中，对于页面的修改我们一般是这样的一个流程，我们对button绑定事件，然后获取文案对应的元素dom对象，然后根据切换修改该dom对象的文案值。

而对于vuejs实现这个功能的流程，只需要在button元素上指明事件，同时声明对应文案的属性，点击事件的时候改变属性的值，对应元素的文本就能够自动的进行切换，我们不需要像以前那样手动的操作dom。

简而言之，就是vuejs帮我们封装了数据和dom对象操作的映射，我们只需要关心数据的逻辑处理，数据的变化就能够自然的通知页面进行页面的重新渲染。

这样做的确实给我们带来的好处，我们不需要再在代码中频繁地去操作dom了，在实际项目中，我们有很大部分代码都是在数据修改以后，手动操作重新渲染页面元素，当页面越来越复杂的时候，页面代码组织会越来难以维护。同时，js对dom的频繁操作，会使得页面代码的出错概率高，页面的视图展示会融合在js代码中，对于页面视图显示的升级也不友好。

那么vuejs是如何实现这种数据驱动的呢？

## MVVM框架

Vuejs的数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewmodel。

- **Model**:指的是数据部分，对应到前端就是javascript对象
- **View**:指的是视图部分，对应前端就是dom
- **Viewmodel**:就是连接视图与数据的中间件

![img](/blog/img/vue/mvvm.jpg)

**数据(Model)** 和 **视图(View)** 是不能直接通讯的，而是需要通过ViewModel来实现双方的通讯。当数据变化的时候，viewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，viewMOdel也能够监听到事件，并通知model进行响应。Viewmodel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。

## 数据驱动实现

对于数据驱动的实现，我们可以简单的通过定时器来实现这个功能，定时器定时监控对象数据，定时器监控数据变化，确定是否更新界面

```js
//数据
var a = 1;

//数据发生变化调用函数
function renderDom(){
    document.getElementById('app').innerHTML = '数据是' + a;
}

//监听函数
function watcher(method){
    var b = a;
    method.apply();
     return setInterval(function(){
       if(b != a){
            method.apply();
            b = a;
       }
    }, 1000)
}

//启动监听函数
watcher(renderDom);
```

当然vuejs不可能是这样简单暴力的实现方式，vuejs是通过在实现一个观察者来实现的数据驱动。

![img](/blog/img/vue/vue-model.png)

首先，vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data 选项，遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter/setter。

同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中,用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。

这样就实现了所谓的数据对于视图的驱动。

### 具体实现代码

#### 定义实现vue对象的结构

```js
class Vue {
    constructor(options) {
        this.$options = options;
        this._data = options.data;
        this.$el = document.querySelector(options.el);
    }
}
```

#### 1. 将data下面的属性变为observable

使用Object.defineProperty对数据对象做属性get和set的监听，当有数据读取和赋值操作时则调用节点的指令，这样使用最通用的=等号赋值就可以触发了。

```js
//数据劫持，监控数据变化
function observer(value, cb){
    Object.keys(value).forEach((key) => defineReactive(value, key, value[key] , cb))
}

function defineReactive(obj, key, val, cb) {
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: ()=>{
            return val
        },
        set: newVal => {
            if(newVal === val)
                return
            val = newVal
        }
    })
}
```

#### 2. 实现一个消息订阅器

很简单，我们维护一个数组，这个数组，就放订阅者，一旦触发notify，订阅者就调用自己的update方法

```js
class Dep {
    constructor() {
        this.subs = []
    }
    add(watcher) {
        this.subs.push(watcher)
    }
    notify() {
        this.subs.forEach((watcher) => watcher.cb())
    }
}
```

每次set函数，调用的时候，我们触发notify，实现更新

那么问题来了。谁是订阅者。对，是Watcher。。一旦 dep.notify()就遍历订阅者，也就是Watcher，并调用他的update()方法

```js
function defineReactive(obj, key, val, cb) {
    const dep = new Dep()
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: ()=>{
            return val
        },
        set: newVal => {
            if(newVal === val)
                return
            val = newVal
            dep.notify()
        }
    })
}
```

### 3. 实现一个 Watcher

Watcher的实现比较简单，其实就是执行数据变化时我们要执行的操作

```js
class Watcher {
    constructor(vm, cb) {
        this.cb = cb
        this.vm = vm
    }
    update(){
        this.run()
    }
    run(){
        this.cb.call(this.vm)
    }
}
```

### 4. touch拿到依赖

上述三步，我们实现了数据改变可以触发更新，现在问题是我们无法将watcher与我们的数据联系到一起。

我们知道data上的属性设置defineReactive后，修改data 上的值会触发 set。那么我们取data上值是会触发 get了。所以可以利用这一点，先执行以下render函数，就可以知道视图的更新需要哪些数据的支持，并把它记录为数据的订阅者。

```js
function defineReactive(obj, key, val, cb) {
    const dep = new Dep()
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: ()=>{
            if(Dep.target){
                dep.add(Dep.target)
            }
            return val
        },
        set: newVal => {
            if(newVal === val)
                return
            val = newVal
            dep.notify()
        }
    })
}
```

最后我们来看用一个代理实现将我们对data的数据访问绑定在vue对象上

```js
_proxy(key) {
    const self = this
    Object.defineProperty(self, key, {
        configurable: true,
        enumerable: true,
        get: function proxyGetter () {
            return self._data[key]
        },
        set: function proxySetter (val) {
            self._data[key] = val
        }
    })
}

Object.keys(options.data).forEach(key => this._proxy(key))
```

### 完整实现

```js
class Vue {
  constructor(options) {
    this.$options = options;
    this._data = options.data;
    this.$el =document.querySelector(options.el);
    Object.keys(options.data).forEach(key => this._proxy(key))
    observer(options.data)
    watch(this, this._render.bind(this), this._update.bind(this))
  }
  _proxy(key) {
    const self = this
    Object.defineProperty(self, key, {
      configurable: true,
      enumerable: true,
      get: function proxyGetter () {
        return self._data[key]
      },
      set: function proxySetter (val) {
        self._data[key] = val
      }
    })
  }
  _update() {
    console.log("我需要更新");
    this._render.call(this)
  }
  _render() {
    this._bindText();
  }

  _bindText() {
    let textDOMs=this.$el.querySelectorAll('[v-text]'),
    bindText;
    for(let i=0;i<textDOMs.length;i++){
       bindText=textDOMs[i].getAttribute('v-text');
       let data = this._data[bindText];
       if(data){
          textDOMs[i].innerHTML=data;
       }      
    }
  }
}

function observer(value, cb){
  Object.keys(value).forEach((key) => defineReactive(value, key, value[key] , cb))
}

function defineReactive(obj, key, val, cb) {
  const dep = new Dep()
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: ()=>{
      if(Dep.target){
        dep.add(Dep.target)
      }
      return val
    },
    set: newVal => {
      if(newVal === val)
        return
      val = newVal
      dep.notify()
    }
  })
}
function watch(vm, exp, cb){
  Dep.target = new Watcher(vm,cb);
  return exp()
}

 class Watcher {
  constructor(vm, cb) {
    this.cb = cb
    this.vm = vm
  }
  update(){
    this.run()
  }
  run(){
    this.cb.call(this.vm)
  }
}

class Dep {
  constructor() {
    this.subs = []
  }
  add(watcher) {
    this.subs.push(watcher)
  }
  notify() {
    this.subs.forEach((watcher) => watcher.cb())
  }
}
Dep.target = null；

 var demo = new Vue({
      el: '#demo',
      data: {
        text: "hello world"
      }
    })

 setTimeout(function(){
   demo.text = "hello new world"

}, 1000)
```

html

```html
<body>
    <div id="demo">
        <div v-text="text"></div>
    </div>
</body>
```
