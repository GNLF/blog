# 实例属性

> 每个 Vue 应用都是通过 Vue 构造函数创建一个新的 Vue 实例开始的。

## Vue构造函数与实例

1. Vue就是一个构造器，通过构造器Vue来实例化一个对象；例如：var vm = new Vue({})；
2. 实例化Vue时，需要传入一个参数（选项对象）；
3. 参数：选项对象可以包含，数据(data)、挂载元素(el)、方法(methods)、模版(template)、生命周期函数等等；
4. 扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用Vue.extend({})来扩展。

```js
var vm = new Vue({
  // 选项
})
```

vm就是Vue的实例。

## Vue选项

| 属性       |                             类型                             | 限制                      | 描述                                                         |
| ---------- | :----------------------------------------------------------: | :------------------------ | :----------------------------------------------------------- |
| el         |                      string\HTMLElement                      | new 创建的实例有效        | 通过CSS选择器与html模板绑定                                  |
| template   |                            string                            | 无限制                    | 一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。 |
| data       |                       Object/function                        | 组件的定义只接受 function | Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。 |
| props      |                         Array/Object                         | 无限制                    | props 可以是数组或对象，用于接收来自父组件的数据。           |
| computed   | {[key: string]: Function } / { get: Function, set: Function } | 无限制                    | 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 |
| methods    |                   [key: string]: Function                    | 无限制                    | methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 |
| watch      |    { [key: string]: string / Function / Object / Array }     | 无限制                    | 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 |
| name       |                            string                            | 作为组件选项起作用        | 允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。 |
| directives |                            Object                            | 无限制                    | 包含 Vue 实例可用指令列表                                    |
| filters    |                            Object                            | 无限制                    | 包含 Vue 实例可用过滤器的哈希表。                            |
| components |                            Object                            | 无限制                    | 包含 Vue 实例可用组件的哈希表。                              |

## 计算属性

模板内的表达式是非常便利的，但是它们实际上只用于简单的运算。在模板中放入太多的逻辑会让模板过重且难以维护。例如：

```html
<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
```

当想要在模板中多次显示 message 的时候，代码会变的很复杂。

这就是对于任何复杂逻辑，你都应当使用计算属性的原因。

### computed属性

```html
<div id="example">
  <p>Original message: "{{ message }}"</p>     
  // Original message: "Hello"

  <p>Computed reversed message: "{{ reversedMessage }}"</p>
  // Computed reversed message: "olleH"
</div>
<script>
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    reversedMessage: function () {
      // 'this' 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</script>
```

`vm.reversedMessage` 依赖于 `vm.message` ，因此当 `vm.message` 发生改变时，所有依赖于 `vm.reversedMessage` 的绑定也会更新。

**计算属性是基于它们的依赖进行缓存的，** 计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。

### methods

`methods` 与 `computed` 写法上的区别是 `computed` 计算属性的方式在用属性时不用加(),而 `methods` 方式在使用时要像方法一样去用，必须加()

```js
<p>Computed reversed message: "{{ reversedMessage() }}"</p>
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

只要发生重新渲染， method调用**总会**执行该函数。在利用实时信息时，比如显示当前进入页面的时间，必须用methods方式 :

```js
methods: {
  now: function () {
    return Date.now()
  }
}
```

如果用computed计算属性的话，每次进入页面将一直沿用第一次的信息，不会再触发now。

**什么时候用 computed ，什么时候用 methods ？**

1. 数据量大，需要缓存的时候用computed；每次确实需要重新加载，不需要缓存时用methods
2. 如果需要传参数，就用methods。

## 侦听属性watch

Vue.js 提供了一个方法 watch，它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。

```js
new Vue({
    data:{
        example0:10,
        example1:20,
        example2:{
            aa:10,
            bb:20
        },
    },
    watch:{
        // 当 example0 的值发生变化时，触发该函数。  函数参数分别为 原始值 和 改变之后的值
        example0:function(newVal,oldVal){
            console.log(newVal,oldVal);
        },

        // 值可以为 methods 的方法名
        example1:fun,

        //注意：当观察的数据为对象或数组时，newVal和oldVal是相等的，因为这两个形参指向的是同一个数据对象
        example2:function(newVal,oldVal){
            console.log(newVal,oldVal);
        }
    },
    methods:{
        fun:function(newVal,oldVal){
            console.log(newVal,oldVal);
        }
    }
})
```

### 深度监听

当我们在监听对象或数组的时候会发现，除非我们对数组或对象重新赋值，否则不会触发监听回调函数。如何让对象或数组添加内容的时候可以触发回调呢？我们需要通过深度监听的方式。

```js
new Vue({
    data:{
        users:[
            {id:100212,name:'zhangsan',age:19},
            {id:100231,name:'lisi',age:22}
        ]
    },
    watch:{
        //深度监听
        users:{
            handler:function(){

            },
            deep:true
        }
    }
    })
```

#### 在vue实例外调用watch

```js
vm.$watch('数据',fn(newVel,oldVel){})
```

- 数据改变时执行函数fn，newVel 变化后的值，oldVel原来的值(可选)
- fn中的 this 表示vm实例
