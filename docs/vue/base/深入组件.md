# 组件知识点

### 命名方案

可以通过两种可选方式，定义组件名称：

#### 串联式命名(kebab-case)

```
Vue.component('my-component-name', { /* ... */ })
```

使用串联式命名(kebab-case)定义一个组件，在引用其自定义元素时，你必须也使用串联式命名(kebab-case)，例如 `<my-component-name>`。

#### Pascal 式命名(PascalCase)

```
Vue.component('MyComponentName', { /* ... */ })
```

使用 Pascal 式命名(PascalCase)定义一个组件，在引用其自定义元素时，两种方式都可以使用。也就是说 `<my-component-name>` 和 `<MyComponentName>` 都是可以接受的。然而要注意，直接在 DOM 中（即，非字符串模板）引用自定义元素，串联式命名(kebab-case)是唯一有效的命名方式。

## 全局注册方式(global registration)

```
Vue.component('my-component-name', {
  // ... options ...
})
```

可以在之后（通过 `new Vue`）创建的 Vue 根实例的模板中引用。例如：

```
Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })

new Vue({ el: '#app' })
<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
```

这甚至可以应用于所有子组件，这意味着，这三个组件还可以在每个其他组件_内部_使用。

## 局部注册方式(local registration)

全局注册方式并不是很合适。例如，如果你使用一个类似 webpack 的模块构建系统，全局注册所有组件，意味着就算你不引用某个组件，它仍然会打包到最终的构建 bundle 中。这会增加 JavaScript 的体积，让用户下载多余的代码。

在下面这些示例中，可以将你的组件定义为纯 JavaScript 对象：

```
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
```

然后，在 `components` 选项中，定义你需要用到的组件：

```
new Vue({
  el: '#app'
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

对于 `components` 对象的每个属性，对象的 key 是自定义元素的名称，而 value 包含着组件的选项对象。

注意，**局部注册的组件在子组件中无法访问**。例如，如果你想要 在 `ComponentB` 中访问 `ComponentA`，你必须使用：

```
var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    'component-a': ComponentA
  },
  // ...
}
```

或者，如果使用 ES2015 模块（例如，通过 Babel 和 webpack 进行转译），则看起来可能类似这样：

```
import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  },
  // ...
}
```

注意，在 ES2015+ 中，在一个对象放置类似 `ComponentA` 这样的变量名称，其实是 `ComponentA: ComponentA` 的简写形式，也就是说，变量的名称：

- 既是在模板中引用的自定义元素的名称
- 而且，也是包含组件选项对象的变量的引用名

## prop 命名方案（驼峰式和串联式）

HTML 属性名称对大小写不敏感，因此浏览器会将所有大写字符解释为小写字符。也就是说。当你在你 DOM 模板中书写 prop 时，你应当将驼峰式(camelCase)转写为等价的（连字符分割的）串联式(kebab-case)：

```
Vue.component('blog-post', {
  // 在 JavaScript 中使用驼峰式(camelCase)
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>'
})
<!-- 在 HTML 中使用串联式(kebab-case) -->
<blog-post post-title="hello!"></blog-post>
```

再次申明，如果是在使用字符串模板的场景，则没有这些限制。

## prop 类型

```
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object
}
```

## 单向数据流

所有 props 都在子组件和父组件之间形成一个**单向往下流动的数据绑定**：当父组件中的属性更新时，数据就会向下流动到子组件，但是反过来，子组件属性更新时，父组件并不会感知到子组件的数据变化。这种机制可以防止子组件意外地修改了父组件的状态，造成应用程序的数据流动变得难于理解。

此外，每次父组件更新时，子组件中所有的 props 都会更新为最新值。也就是说，你**不应该**试图在子组件内部修改 prop。如果你这么做，Vue 就会在控制台给出警告。

诱使我们修改 prop 的原因，通常有两种：

1. **prop 用于传递初始值(initial value)；之后子组件需要将 prop 转为一个局部数据属性。**在这种情况中，最好定义一个局部的 data 属性，然后将 prop 的值，作为局部属性初始值。

   ```
   props: ['initialCounter'],
   data: function () {
     return {
       counter: this.initialCounter
     }
   }
   ```

2. **prop 用于传递一个需要转换的未加工值(raw value)。**在这种情况中，最好预先定义一个 computed 属性，然后在其函数内部引用 prop 的值：

   ```
   props: ['size'],
   computed: {
     normalizedSize: function () {
       return this.size.trim().toLowerCase()
     }
   }
   ```

注意，JavaScript 中的对象和数组都是通过引用(reference)传递的，因此，如果 prop 是一个数组或对象，则在子组件内部改变对象或数组本身，**仍然会**影响到父组件状态。

## prop 验证

```
Vue.component('my-component', {
  props: {
    // 基本类型(base type)的检查（`null` 表示接受所有类型）
    propA: Number,
    // 多种可能的类型
    propB: [String, Number],
    // 必须传递，且 String 类型
    propC: {
      type: String,
      required: true
    },
    // Number 类型，有一个默认值
    propD: {
      type: Number,
      default: 100
    },
    // Object 类型，有一个默认值
    propE: {
      type: Object,
      // Object/Array 类型，
      // 默认必须返回一个工厂函数
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 值必须是这些字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
```

### 类型检查

`type` 可以是以下原生构造函数之一：

- String
- Number
- Boolean
- Array
- Object
- Date
- Function
- Symbol

## 非 prop 特性(non-prop attributes)

非 prop 特性，就是指无须遵循 prop 定义规则，而是可以直接传入到组件的 HTML 属性(attribute)。

```
<bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>
```

然后，`data-date-picker="activated"` 特性就会被自动添加到 `bootstrap-date-input` 组件的根元素上。