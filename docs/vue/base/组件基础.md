# 组件基础

## 基本示例

这里是一个 Vue 组件示例：

```js
// 定义一个新的组件，名称为 button-counter
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">你点击了 {{ count }} 次。</button>'
})
```

组件(component)，是具有 name 名称的可复用 Vue 实例：当前示例中是 `<button-counter>`。我们可以使用 `new Vue` 创建出一个 Vue 根实例，然后将这个组件作为其中的一个自定义元素(custom element)：

```html
<div id="components-demo">
  <button-counter></button-counter>
</div>
new Vue({ el: '#components-demo' })
```

由于组件是可复用的 Vue 实例，它们接收的选项，和在 `new Vue` 时候的选项相同，例如 `data`, `computed`, `watch`, `methods` 和生命周期钩子。唯一的例外是，类似 `el` 这样，根实例上特有(root-specific)的选项。

## 重复使用组件

可以根据需要，多次重复使用组件：

```html
<div id="components-demo">
  <button-counter></button-counter>
  <button-counter></button-counter>
  <button-counter></button-counter>
</div>
```

你点击了 0 次。 你点击了 0 次。 你点击了 0 次。

注意，当点击按钮时，每个按钮都维护彼此独立的 `count`。这是因为每次使用组件时，都会创建出一个新的**组件实例**。

### `data` 必须是一个函数

当我们定义 `<button-counter>` 组件时，你可能已经注意到，提供给组件定义对象的 `data`，并不是如下所示的一个对象：

```js
data: {
  count: 0
}
```

相反，**组件的 data 选项必须是一个函数**，以便每个实例都可以维护「函数返回的数据对象」的彼此独立的数据副本：

```js
data: function () {
  return {
    count: 0
  }
}
```

如果 Vue 没有遵循这个规定，点击其中一个按钮，会影响其他所有用到此 data 的组件实例

## 将组件组合在一起

通常都会将一个应用程序，组织为一个嵌套的组件树：

![组件树](/img/vue/components.png)

例如，你的组件可能有 header，sidebar 和 content 三个区域，每个组件都包含导航链接、博客文章等其他组件。

想要在模板中使用这些组件，就必须先进行注册，以便 Vue 能够找到它们。组件注册有两种方式：**全局注册**和**局部注册**。到目前为止，我们只通过 `Vue.component` 在全局注册组件：

```js
Vue.component('my-component-name', {
  // ... options ...
})
```

全局方式注册的组件，可以用于之后创建的所有（通过 `new Vue` 创建的）Vue 根实例，以及 Vue 实例组件树中所有子组件的内部。

现在，你仅需要知道组件注册的这些相关知识，等到你阅读完这个页面，并且能够很好适应这些内容，我们建议你稍后回到这里，继续深入阅读 [组件注册](https://vue.docschina.org/v2/guide/components-registration.html) 的完整指南。

## 使用 props 向子组件传递数据

props 是指注册在组件选项上的自定义属性。当一个值，被放置在 props 中，作为其中一个 prop，这个值就会成为组件实例上，一个可访问的属性。想要向我们的文章组件传递一个标题，我们需要在此组件接收 props 的 list 清单中将其置入，通过使用一个 `props` 来进行：

```js
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>'
})
```

一个组件可以有很多 prop，并且默认情况下，任何类型的值都可以传递给 prop。在上面的 template 模板中，你可以看到我们可以在组件实例上访问到 title 这个值，就像我们访问 `data` 上的 title 一样。

在预先注册好一个 prop 属性之后，就可以将数据作为自定义属性传递给这个 prop 属性，如下所示：

```js
<blog-post title="我的 Vue 旅程"></blog-post>
<blog-post title="用 Vue 写博客"></blog-post>
<blog-post title="Vue 如此有趣"></blog-post>
```

## 单个根元素

## 使用 events 向父组件发送消息

在我们开发 `<blog-post>` 组件时，有些功能可能恰好与 props 相反，需要子组件反过来和父组件进行通信。

想要向父组件发送事件，可以调用实例中内置的 [**$emit** 方法](https://vue.docschina.org/v2/api/#vm-emit)，传递事件名称：

```html
<button v-on:click="$emit('enlarge-text')">
  放大文本
</button>
```

## 使用 slots 进行内容分发

如同在 HTML 元素中传入内容，我们也经常会向组件传入内容，就像这样：

```js
<alert-box>
  发生一些错误。
</alert-box>
```

会被渲染为如下结果：

**Error!** 发生一些错误。

幸运的是，通过 Vue 的 `<slot>` 自定义元素，可以非常简单的实现这个任务：

```js
Vue.component('alert-box', {
  template: `
    <div class="demo-alert-box">
      <strong>Error!</strong>
      <slot></slot>
    </div>
  `
})
```

就像你看到的，我们只是将其插入到我们想要它在的位置 - 就像这样。我们已经实现了预期！

现在，你仅需要知道 slot(插槽) 的这些相关知识，等到你阅读完整个页面，并且能够很好适应这些内容，我们建议你稍后回到这里，继续深入阅读 [slot(插槽)](https://vue.docschina.org/v2/guide/components-slots.html) 的完整指南。

## 动态组件

有时，在组件之间进行动态切换非常有用，例如在标签式界面中：

Home 组件

通过向 Vue 的 `<component>` 元素传入 `is` 特性，可以实现以上效果：

```html
<!-- Component changes when currentTabComponent changes -->
<component v-bind:is="currentTabComponent"></component>
```

在上面的示例中，`currentTabComponent` 也可以是以下之一：

- 已注册组件的注册名称(registered name)
- 或者是一个组件选项对象(options object)

在 fiddle中查看 注册名称方式 的完整代码并体验效果，或者在 这个 fiddle 中查看 选项对象方式。

现在，你仅需要知道 动态组件 的这些相关知识，等到你阅读完整个页面，并且能够很好适应这些内容，我们建议你稍后回到这里，继续深入阅读 [动态组件和异步组件](https://vue.docschina.org/v2/guide/components-dynamic-async.html) 的完整指南。

## DOM 模板解析注意事项

有些　HTML 元素，例如 `<ul>`, `<ol>`, `<table>` 和 `<select>` 这些元素，会对于出现在其内部的元素有所限制；而另一些　HTML 元素，例如 `<li>`, `<tr>` 和 `<option>` 这些元素，只可以出现在前面那些元素的内部。

由于这种 HTML 运行机制，在这些受限制的元素内部使用组件，会导致一些问题。例如：

```html
<table>
  <blog-post-row></blog-post-row>
</table>
```

自定义组件 `<blog-post-row>` 会被当作无效内容，提升到 table 元素之外，从而导致最终渲染输出后的错误。幸运的是，`is` 特性提供了一种解决方案：

```html
<table>
  <tr is="blog-post-row"></tr>
</table>
```

应当注意，**在使用以下字符串模板之一的场景中，这些限制将不再适用**：

- 字符串模板（例如 `template: '...'`）
- 单文件 (`.vue`) 组件

### 自动化全局注册基本组件

许多相对通用的组件，例如，内部可能只含有一个 input 或 button 元素。我们有时将这些组件归为基础组件，并且往往在其他组件中频繁使用这类组件。

结果就是，许多组件可能会列出一个很长的基础组件清单，然后在 components 选项中进行逐个引用：

```js
import BaseButton from './BaseButton.vue'
import BaseIcon from './BaseIcon.vue'
import BaseInput from './BaseInput.vue'

export default {
  components: {
    BaseButton,
    BaseIcon,
    BaseInput
  }
}
```

这么麻烦的操作，也只是为了在模板中，支持相对很少用到的组件标签：

```html
<BaseInput
  v-model="searchText"
  @keydown.enter="search"
/>
<BaseButton @click="search">
  <BaseIcon name="search"/>
</BaseButton>
```

幸运的是，如果你正在使用 webpack（或者内置 webpack 的 [Vue CLI 3+](https://github.com/vuejs/vue-cli)），你就可以只通过 `require.context` 来全局注册这些常用基础组件。在你的应用程序入口文件（例如 `src/main.js`）中，你可能会通过全局方式导入基础组件，下面是一些示例代码：

```js
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // components 文件夹的相对路径
  './components',
  // 是否查找子文件夹
  false,
  // 用于匹配组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)

  // 取得组件的 Pascal 式命名
  const componentName = upperFirst(
    camelCase(
      // 将文件名前面的 `./` 和扩展名剥离
      fileName.replace(/^\.\/(.*)\.\w+$/, '$1')
    )
  )

  // 以全局方式注册组件
  Vue.component(
    componentName,
    // 如果组件是通过 `export default` 导出，
    // 则在 `.default` 中，查找组件选项，
    // 否则回退至模块根对象中，查找组件选项
    componentConfig.default || componentConfig
  )
})
```

切记，**全局注册方式必须在（通过 new Vue 创建的）Vue 根实例创建之前置入组件**。这里是按照以上所述的，一个真实项目环境[示例](https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js).
